<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>灵魂三问 | 无来</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="喵巨人学习笔记，包含前端开发、后端开发、服务器运维等">
    
    <link rel="preload" href="/assets/css/0.styles.9825735b.css" as="style"><link rel="preload" href="/assets/js/app.a29618bb.js" as="script"><link rel="preload" href="/assets/js/2.dc5a3d57.js" as="script"><link rel="preload" href="/assets/js/37.e7e4c62c.js" as="script"><link rel="prefetch" href="/assets/js/10.aadb897e.js"><link rel="prefetch" href="/assets/js/11.eca80b3f.js"><link rel="prefetch" href="/assets/js/12.19363ad1.js"><link rel="prefetch" href="/assets/js/13.127ff178.js"><link rel="prefetch" href="/assets/js/14.3cd2f239.js"><link rel="prefetch" href="/assets/js/15.538cefeb.js"><link rel="prefetch" href="/assets/js/16.3500b3bd.js"><link rel="prefetch" href="/assets/js/17.5ffdede6.js"><link rel="prefetch" href="/assets/js/18.916a75d6.js"><link rel="prefetch" href="/assets/js/19.fc3cc93a.js"><link rel="prefetch" href="/assets/js/20.f0477324.js"><link rel="prefetch" href="/assets/js/21.6c4b36ad.js"><link rel="prefetch" href="/assets/js/22.c2dd175e.js"><link rel="prefetch" href="/assets/js/23.d1c0bcb3.js"><link rel="prefetch" href="/assets/js/24.e65bae75.js"><link rel="prefetch" href="/assets/js/25.723147ab.js"><link rel="prefetch" href="/assets/js/26.54701d04.js"><link rel="prefetch" href="/assets/js/27.f435a237.js"><link rel="prefetch" href="/assets/js/28.b864ad17.js"><link rel="prefetch" href="/assets/js/29.3aeb42ce.js"><link rel="prefetch" href="/assets/js/3.abf548e5.js"><link rel="prefetch" href="/assets/js/30.68b8c702.js"><link rel="prefetch" href="/assets/js/31.070ea1e6.js"><link rel="prefetch" href="/assets/js/32.e2a2d877.js"><link rel="prefetch" href="/assets/js/33.0fd843a8.js"><link rel="prefetch" href="/assets/js/34.64359902.js"><link rel="prefetch" href="/assets/js/35.0cf504f2.js"><link rel="prefetch" href="/assets/js/36.ac459f7f.js"><link rel="prefetch" href="/assets/js/38.b06ca27a.js"><link rel="prefetch" href="/assets/js/39.0139207a.js"><link rel="prefetch" href="/assets/js/4.43879640.js"><link rel="prefetch" href="/assets/js/40.dad79de7.js"><link rel="prefetch" href="/assets/js/41.8251a988.js"><link rel="prefetch" href="/assets/js/42.9b2e8121.js"><link rel="prefetch" href="/assets/js/43.873f6ee0.js"><link rel="prefetch" href="/assets/js/44.d040e366.js"><link rel="prefetch" href="/assets/js/45.c8e42e15.js"><link rel="prefetch" href="/assets/js/46.74b44b9b.js"><link rel="prefetch" href="/assets/js/47.c4cca17a.js"><link rel="prefetch" href="/assets/js/48.d3c09982.js"><link rel="prefetch" href="/assets/js/49.06f17338.js"><link rel="prefetch" href="/assets/js/5.60572b82.js"><link rel="prefetch" href="/assets/js/50.f301b1c6.js"><link rel="prefetch" href="/assets/js/51.fd40f759.js"><link rel="prefetch" href="/assets/js/52.f99fd59f.js"><link rel="prefetch" href="/assets/js/53.f85ba0a4.js"><link rel="prefetch" href="/assets/js/54.42d934c9.js"><link rel="prefetch" href="/assets/js/55.8d801eee.js"><link rel="prefetch" href="/assets/js/56.86e31694.js"><link rel="prefetch" href="/assets/js/57.2f9cced8.js"><link rel="prefetch" href="/assets/js/58.e1cae155.js"><link rel="prefetch" href="/assets/js/59.8a9a4372.js"><link rel="prefetch" href="/assets/js/6.22f00265.js"><link rel="prefetch" href="/assets/js/60.a0380038.js"><link rel="prefetch" href="/assets/js/61.472ce500.js"><link rel="prefetch" href="/assets/js/62.c1e9287b.js"><link rel="prefetch" href="/assets/js/7.c751c35f.js"><link rel="prefetch" href="/assets/js/8.dc5926d2.js"><link rel="prefetch" href="/assets/js/9.298e7fa8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9825735b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无来</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/1.基础知识/" class="sidebar-heading clickable"><span>基础知识</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/1.基础知识/css 加载会阻塞浏览器的执行吗.html" class="sidebar-link">css 加载会阻塞浏览器的执行吗</a></li><li><a href="/1.基础知识/tcp、udp的区别以及七层模型.html" class="sidebar-link">tcp、udp的区别以及七层模型</a></li><li><a href="/1.基础知识/v8如何执行一段代码.html" class="sidebar-link">v8如何执行一段代码</a></li><li><a href="/1.基础知识/vue 和 react 的区别.html" class="sidebar-link">vue 和 react 的区别</a></li><li><a href="/1.基础知识/性能指标.html" class="sidebar-link">性能指标</a></li><li><a href="/1.基础知识/浏览器输入url后发生了什么.html" class="sidebar-link">浏览器输入url后发生了什么</a></li><li><a href="/1.基础知识/理解 node 中的几个路径.html" class="sidebar-link">理解 node 中的几个路径</a></li><li><a href="/1.基础知识/线程、进程以及浏览器主要进程理解.html" class="sidebar-link">线程、进程以及浏览器主要进程理解</a></li><li><a href="/1.基础知识/记录一次SameSite的问题.html" class="sidebar-link">记录一次SameSite的问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/10.webpack/" class="sidebar-heading clickable"><span>webpack</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/10.webpack/webpack 模块化源码分析.html" class="sidebar-link">webpack 模块化源码分析</a></li><li><a href="/10.webpack/打包情况视图.html" class="sidebar-link">打包情况视图</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/2.js深入浅出/" class="sidebar-heading clickable"><span>js深入浅出</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/2.js深入浅出/es6-let和const.html" class="sidebar-link">es6-let和const</a></li><li><a href="/2.js深入浅出/es6-箭头函数.html" class="sidebar-link">es6-箭头函数</a></li><li><a href="/2.js深入浅出/js-new的原理.html" class="sidebar-link">js-new的原理</a></li><li><a href="/2.js深入浅出/js-原型.html" class="sidebar-link">js-原型</a></li><li><a href="/2.js深入浅出/map,setMap以及set,wekSet的区别.html" class="sidebar-link">map,setMap以及set,wekSet的区别</a></li><li><a href="/2.js深入浅出/null 和 undefined 的区别.html" class="sidebar-link">null 和 undefined 的区别</a></li><li><a href="/2.js深入浅出/sort 的内部实现.html" class="sidebar-link">sort 的内部实现</a></li><li><a href="/2.js深入浅出/函数执行过程.html" class="sidebar-link">函数执行过程</a></li><li><a href="/2.js深入浅出/判断类型.html" class="sidebar-link">判断类型</a></li><li><a href="/2.js深入浅出/数组的冷知识.html" class="sidebar-link">数组的冷知识</a></li><li><a href="/2.js深入浅出/模块化及区别.html" class="sidebar-link">模块化及区别</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/3.手写系列/" class="sidebar-heading clickable"><span>手写系列</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/3.手写系列/实现一个 Vuex 核心功能.html" class="sidebar-link">实现一个 Vuex 核心功能</a></li><li><a href="/3.手写系列/实现一个 tcp 以及 http 服务.html" class="sidebar-link">实现一个 tcp 以及 http 服务</a></li><li><a href="/3.手写系列/实现一个千分位分隔符.html" class="sidebar-link">实现一个千分位分隔符</a></li><li><a href="/3.手写系列/手写call,bind,apply.html" class="sidebar-link">手写call,bind,apply</a></li><li><a href="/3.手写系列/装饰器.html" class="sidebar-link">装饰器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/4.vue/" class="sidebar-heading clickable router-link-active open"><span>vue</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/4.vue/使用动态插槽灵活封装 table 组件.html" class="sidebar-link">使用动态插槽灵活封装 table 组件</a></li><li><a href="/4.vue/开发心得-自定义指令的妙用.html" class="sidebar-link">开发心得-自定义指令的妙用</a></li><li><a href="/4.vue/详解 computed 的实现原理.html" class="active sidebar-link">详解 computed 的实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/4.vue/详解 computed 的实现原理.html#灵魂三问" class="sidebar-link">灵魂三问</a></li><li class="sidebar-sub-header"><a href="/4.vue/详解 computed 的实现原理.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/4.vue/详解 computed 的实现原理.html#初始化过程" class="sidebar-link">初始化过程</a></li><li class="sidebar-sub-header"><a href="/4.vue/详解 computed 的实现原理.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/4.vue/详解 watch 的实现原理.html" class="sidebar-link">详解 watch 的实现原理</a></li><li><a href="/4.vue/详解响应式原理.html" class="sidebar-link">详解响应式原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/5.react/" class="sidebar-heading clickable"><span>react</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/5.react/umi中 react嵌套路由父给子路由传参.html" class="sidebar-link">umi中 react嵌套路由父给子路由传参</a></li><li><a href="/5.react/使用context.html" class="sidebar-link">使用context</a></li><li><a href="/5.react/解决react路由参数报错.html" class="sidebar-link">解决react路由参数报错</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/7.奇奇怪怪的知识点/" class="sidebar-heading clickable"><span>奇奇怪怪的知识点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/7.奇奇怪怪的知识点/一个会卡死的正则.html" class="sidebar-link">一个会卡死的正则</a></li><li><a href="/7.奇奇怪怪的知识点/为什么数组中不能展开一个对象.html" class="sidebar-link">为什么数组中不能展开一个对象</a></li><li><a href="/7.奇奇怪怪的知识点/为什么要使用 require 引入动态图片.html" class="sidebar-link">为什么要使用 require 引入动态图片</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/8.docker/" class="sidebar-heading clickable"><span>docker</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/8.docker/docker+jenkins自动化部署.html" class="sidebar-link">docker+jenkins自动化部署</a></li><li><a href="/8.docker/记录一次docker的学习.html" class="sidebar-link">记录一次docker的学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/9.nginx/" class="sidebar-heading clickable"><span>nginx</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/9.nginx/nginx 添加环境变量.html" class="sidebar-link">nginx 添加环境变量</a></li><li><a href="/9.nginx/记录一次nginx反向代理跨域的学习.html" class="sidebar-link">记录一次nginx反向代理跨域的学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/算法/" class="sidebar-heading clickable"><span>算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/算法/子集,全排列.html" class="sidebar-link">子集,全排列</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="灵魂三问"><a href="#灵魂三问" class="header-anchor">#</a> 灵魂三问</h2> <p>带着问题看源码：</p> <ol><li><code>computed</code> 是如何实现缓存的？</li> <li><code>computed</code> 是如何收集依赖数据的？</li> <li><code>computed</code>依赖数据更新之后是如何更新视图的？</li></ol> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>相信<code>computed</code>都用过.那么,知其然知其所以然?</p> <h3 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h3> <p><code>computed</code> 是 <code>vue</code> 中的计算属性, 根据依赖关系进行计算并缓存, 只有当依赖被改变的时候才会更新</p> <p><code>computed</code> 一般用于一些复杂的场景, 如受多个数据共同影响的场景</p> <h3 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h3> <p><code>computed</code> 有两种用法</p> <p>一种是常规的函数写法, 默认使用 <code>getter</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>

  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>

  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其实还可以使用对象的写法, 设置 <code>computed</code> 的 <code>getter</code>, 当值被修改的时候同时修改依赖的属性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>

  <span class="token literal-property property">getName</span><span class="token operator">:</span> <span class="token punctuation">{</span>

    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> last<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> first<span class="token punctuation">;</span>
    
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> last<span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token punctuation">}</span><span class="token punctuation">,</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>下面跟着源码直接进入正题</p> <h2 id="初始化过程"><a href="#初始化过程" class="header-anchor">#</a> 初始化过程</h2> <p><code>new Vue(computed)</code> =&gt; <code>initState</code> =&gt; <code>initComputed</code> =&gt; <code>defineComputed[key]</code> =&gt; <code>createComputedGetter</code> =&gt;<code>mountComponent</code></p> <p>大致介绍一下整个流程:</p> <ol><li>首先在 <code>initState</code> 中对传入的 <code>computed</code> 进行初始化</li> <li>初始化的过程中, 为每一个声明的 <code>computed</code>创建 <code>Watcher</code>, 将声明时传入的函数(或者对象声明的 <code>get</code>) 传递给创建的<code>Watcher</code>用于被访问时执行,利用 <code>defineProperty</code> 将声明的 <code>computed</code> 代理到 <code>vm</code> 实例上, 从而跟 <code>data</code> 一样可以通过 <code>this</code> 来访问, <strong>同时用一个函数包装<code>computed</code>的<code>getter</code>(实现缓存的关键)</strong> , 当<code>computed</code>被访问时将执行该函数, 判断是否使用缓存值</li> <li>初始化结束之后会执行 <code>vm.$mount</code>, 对视图进行渲染, 渲染过程中会执行 <code>vm._render</code> 生成 <code>vnode</code> 由于解析到 <code></code> 会触发之前劫持的 <code>getter</code>, 从而执行声明<code>computed</code>时的函数</li> <li>执行声明时传入的函数时, 由于初始化<code>dirty=true</code>, 因此会去获取最新值, 此时会触发其所引用的<code>data</code>中数据的<code>getter</code>, 从而触发响应式系统的依赖收集.<strong>由于此时的 <code>Dep.target</code>为该<code>computerWatcher</code></strong>, 因此会收集该<code>computerWatcher</code>为依赖项</li> <li>当<code>computed</code>依赖的数据被更新时, 会进行消息分发,执行<code>watcher.update()</code>, 若<code>watcher</code>为<code>computedWatcher</code>则将<code>dirty</code>标记为<code>true</code>, 当前订阅的<code>computed</code>被访问时, 触发之前被函数包装的<code>getter</code>, 函数内部识别到<code>dirty===true</code>则获取最新值, 获取完之后接着将<code>dirty</code>置位<code>false</code>. <strong>由于被依赖的数据订阅者中还有用于视图更新的<code>renderWatcher</code>, 因此会接着对视图更新从而渲染最新数据, 这也说明 <code>computedWatcher</code> 要在 <code>renderWatcher</code>之前去更新</strong></li></ol> <p>主要代码如下:</p> <h3 id="initcomputed-创建-computedwatcher"><a href="#initcomputed-创建-computedwatcher" class="header-anchor">#</a> initComputed =&gt; 创建 computedWatcher</h3> <ol><li>在<code>Vue</code>实例上挂载<code>_computedWatchers</code>属性用来存放所有<code>computedWatcher</code></li> <li>为每一个计算属性创建<code>computedWatcher</code></li> <li>使用<code>defineComputed</code>处理定义的每个<code>computed</code></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// src/core/instance/state.js  </span>
<span class="token keyword">function</span> <span class="token function">initComputed</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component<span class="token punctuation">,</span> <span class="token literal-property property">computed</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/** 在vm实例上挂载 _computedWatchers 属性存放 computerwatcher */</span>
  <span class="token keyword">const</span> watchers <span class="token operator">=</span> vm<span class="token punctuation">.</span>_computedWatchers <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token comment">/** 判断是否服务端 */</span>
  <span class="token keyword">const</span> isSSR <span class="token operator">=</span> <span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token comment">/**
     * 1. 判断 computed 属于默认函数写法,还是对象写法  
     * 2. 如果是对象写法则将定义的 get 赋值给 getter
     */</span>
    <span class="token keyword">const</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> userDef <span class="token operator">:</span> userDef<span class="token punctuation">.</span>get

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSSR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/** 可以看出本质上 computed 就是一个 watchers 数组, 每一个定义的 computed 都是一个 watcher(computedWatcher) */</span>
      watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>
        vm<span class="token punctuation">,</span>
        <span class="token comment">/** 将之前申明的 getter 传入 watcher 的 expOrFn, 当 dep.notify 的时候将会执行 */</span>
        getter <span class="token operator">||</span> noop<span class="token punctuation">,</span>
        noop<span class="token punctuation">,</span>
        <span class="token comment">/** computed 实现缓存关键, 值为上面定义的 { lazy: true } */</span>
        computedWatcherOptions
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** 判断是否有重复的申明 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="definecomputed-劫持-getter-实现缓存"><a href="#definecomputed-劫持-getter-实现缓存" class="header-anchor">#</a> defineComputed =&gt; 劫持 getter, 实现缓存</h3> <ol><li>使用<code>Object.defineProperty</code>将计算属性挂载到 <code>vue</code> 实例上, 使其可以通过 <code>this</code> 访问</li> <li>使用 <code>createComputedGetter</code> 包装计算属性的<code>getter</code>函数, 当计算属性被访问的时候执行.通过<code>dirty</code>变量标记是否去获取最新数据</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// src/core/instance/state.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">defineComputed</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
  <span class="token literal-property property">userDef</span><span class="token operator">:</span> Object <span class="token operator">|</span> Function</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/** 判断 computed 属于函数式写法还是对象写法, 目的是拿到其执行函数 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sharedPropertyDefinition<span class="token punctuation">.</span>get <span class="token operator">=</span> shouldCache
      <span class="token operator">?</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>userDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sharedPropertyDefinition<span class="token punctuation">.</span>set <span class="token operator">=</span> noop<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token comment">/** 挂载到 vue 实例, 通过 this 可以访问 */</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">computedGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/** 如果&quot;脏了&quot;, 表示依赖数据被更新, 则需要获取最新数据 */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/** 
         * 1. 本质是调用创建 computedWatcher 时, 传入的方法即定义 computed 时写的方法, 从而更新 Watcher 的 value 为最新值 
         * 2. 获取数据之后, 同时将 dirty 置位 false, 进行缓存
         * */</span>
        watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">/** 如果有依赖正在收集, 则将该 watcher 下所有发布者添加到正在收集依赖的 watcer 发布者列表里 */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>这里注意一下有这样一步<code>watcher.depend()</code>, 目的是将该 <code>computedWatcher</code>的发布者添加到当前正在收集依赖的<code>Watcher</code>.</p> <p>首先初次渲染页面时, 由<code>renderWatcher</code>进行依赖收集, 当解析模板发现<code></code>时, 触发计算属性的 <code>getter</code>, 执行 <code>watcher.get</code>,此时会将当前<code>watcher</code>压入<code>targetStack</code>依赖收集栈, 同时执行<code>Dep.target = target</code>.即将此时进行依赖收集的<code>renderWatcher</code>修改为当前<code>computedWathcer</code>. 执行计算属性定义函数时,访问到依赖数据,触发响应式系统将<code>Dep.target</code>加入订阅者<code>subs</code>列表中.依赖收集完毕,执行<code>popTarget()</code>弹出收集栈,此时<code>Dep.target</code>修改为之前的<code>renderWatcher</code></p> <p>因此<code>watcher.depend()</code>的最终目的就是将<code>computedWatcher</code>的发布者添加到<code>renderWatcher</code>的发布者列表中, 如果不执行这一步, 计算属性所依赖的属性修改之后,不会触发视图更新, 因为有可能<code>template</code>中只引用了计算属性而没有引用计算属性内部依赖的数据, <code>renderWatcher</code>并没有对依赖数据进行订阅.</p> <h3 id="数据更新"><a href="#数据更新" class="header-anchor">#</a> 数据更新</h3> <p>当计算属性依赖数据被更新时, 会触发响应式数据的<code>setter</code>, 执行<code>dep.notify</code>对所有订阅者进行订阅发布</p> <p>当订阅者为<code>computedWatcher</code>时, 将内部的<code>dirty</code>置为<code>true</code></p> <p>当订阅者为<code>renderWatcher</code>时, 执行<code>vm._update(vm._render)</code>更新视图.扫描数据的同时, 访问到计算属性, 则会执行之前<code>createComputedGetter</code>包装的<code>getter</code>函数, 由于当前<code>computedWatcher</code>内部的<code>dirty</code>已经在上一步被标记为<code>true</code>, 因此会刷新<code>watcher.value</code>, 刷新之后将<code>dirty</code>置为<code>false</code>. 若<code>dirty</code>为<code>false</code>, 则直接获取<code>watcher.value</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// src/core/observer/watcher.js</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 如果this.lazy为true, 说明是 computedWatcher, 通过dirty标记为有更新, 当下一次 computed 被访问的时候, 识别到该字段则会进行数据更新 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>回顾一下之前的问题:</p> <ol><li><code>computed</code> 是如何实现缓存的？</li></ol> <p>答: 通过<code>createComputedGetter</code>包装计算属性的<code>getter</code>,使用<code>dirty</code>标记所依赖的数据有没有更新, 若更新则刷新数据,否则直接返回<code>watcher.value</code></p> <ol start="2"><li><code>computed</code> 是如何收集依赖数据的？</li></ol> <p>答: <code>computed</code>本质上就是一个<code>watcher</code>, 在执行<code>watcher.get</code>时会访问到计算属性所依赖的数据,触发依赖收集系统. 此时的订阅者<code>Dep.target</code>为该<code>coomputedWatcher</code>, 订阅方为所有依赖数据.</p> <ol start="3"><li><code>computed</code>依赖数据更新之后是如何更新视图的？</li></ol> <p>答: 当<code>computed</code>内部依赖数据进行依赖收集的之后, 会将当前<code>renderWatcher</code>也加入到订阅队列中, 即依赖数据更新后先触发<code>computedWatcher.update</code>的, 然后触发<code>renderWatcher.update</code>更新视图</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2/5/2023, 6:54:08 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/4.vue/开发心得-自定义指令的妙用.html" class="prev">
        开发心得-自定义指令的妙用
      </a></span> <span class="next"><a href="/4.vue/详解 watch 的实现原理.html">
        详解 watch 的实现原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a29618bb.js" defer></script><script src="/assets/js/2.dc5a3d57.js" defer></script><script src="/assets/js/37.e7e4c62c.js" defer></script>
  </body>
</html>
