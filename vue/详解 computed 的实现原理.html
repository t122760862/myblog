<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>灵魂三问 | 无来</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="喵巨人学习笔记，包含前端开发、后端开发、服务器运维等">
    
    <link rel="preload" href="/assets/css/0.styles.9825735b.css" as="style"><link rel="preload" href="/assets/js/app.b1ceb87a.js" as="script"><link rel="preload" href="/assets/js/2.dc5a3d57.js" as="script"><link rel="preload" href="/assets/js/29.2ae39443.js" as="script"><link rel="prefetch" href="/assets/js/10.d20efabc.js"><link rel="prefetch" href="/assets/js/11.6332ad67.js"><link rel="prefetch" href="/assets/js/12.b4a6d434.js"><link rel="prefetch" href="/assets/js/13.9bcfdc6f.js"><link rel="prefetch" href="/assets/js/14.b3f3cf47.js"><link rel="prefetch" href="/assets/js/15.c7b3a34d.js"><link rel="prefetch" href="/assets/js/16.bdfab345.js"><link rel="prefetch" href="/assets/js/17.3f94594e.js"><link rel="prefetch" href="/assets/js/18.d62bd910.js"><link rel="prefetch" href="/assets/js/19.0bffe270.js"><link rel="prefetch" href="/assets/js/20.26fba023.js"><link rel="prefetch" href="/assets/js/21.bc230ce5.js"><link rel="prefetch" href="/assets/js/22.7c254f6e.js"><link rel="prefetch" href="/assets/js/23.90e2dcab.js"><link rel="prefetch" href="/assets/js/24.d060e7a1.js"><link rel="prefetch" href="/assets/js/25.41302e5e.js"><link rel="prefetch" href="/assets/js/26.9c9a6254.js"><link rel="prefetch" href="/assets/js/27.3583fe00.js"><link rel="prefetch" href="/assets/js/28.bd5344f3.js"><link rel="prefetch" href="/assets/js/3.496155bf.js"><link rel="prefetch" href="/assets/js/30.241639f7.js"><link rel="prefetch" href="/assets/js/31.b5cbb497.js"><link rel="prefetch" href="/assets/js/32.5732facd.js"><link rel="prefetch" href="/assets/js/33.af610e19.js"><link rel="prefetch" href="/assets/js/34.c0c11283.js"><link rel="prefetch" href="/assets/js/35.3f2b1c1b.js"><link rel="prefetch" href="/assets/js/36.08744dc8.js"><link rel="prefetch" href="/assets/js/37.6f8bce4a.js"><link rel="prefetch" href="/assets/js/38.28686f08.js"><link rel="prefetch" href="/assets/js/39.2e0baa59.js"><link rel="prefetch" href="/assets/js/4.43879640.js"><link rel="prefetch" href="/assets/js/40.c56df018.js"><link rel="prefetch" href="/assets/js/41.90217eb2.js"><link rel="prefetch" href="/assets/js/42.94a52d3b.js"><link rel="prefetch" href="/assets/js/43.876f89ae.js"><link rel="prefetch" href="/assets/js/44.f120de0a.js"><link rel="prefetch" href="/assets/js/45.81fb8787.js"><link rel="prefetch" href="/assets/js/46.d8c7c3fd.js"><link rel="prefetch" href="/assets/js/47.068fffd6.js"><link rel="prefetch" href="/assets/js/48.eef37724.js"><link rel="prefetch" href="/assets/js/49.fd797564.js"><link rel="prefetch" href="/assets/js/5.60572b82.js"><link rel="prefetch" href="/assets/js/50.e291ff87.js"><link rel="prefetch" href="/assets/js/51.34268a37.js"><link rel="prefetch" href="/assets/js/52.c3696398.js"><link rel="prefetch" href="/assets/js/53.b648620c.js"><link rel="prefetch" href="/assets/js/54.f8f70714.js"><link rel="prefetch" href="/assets/js/55.6a0cf27a.js"><link rel="prefetch" href="/assets/js/56.a60c03ca.js"><link rel="prefetch" href="/assets/js/57.8ba7ae3c.js"><link rel="prefetch" href="/assets/js/58.1f7f9c42.js"><link rel="prefetch" href="/assets/js/59.682dc35d.js"><link rel="prefetch" href="/assets/js/6.22f00265.js"><link rel="prefetch" href="/assets/js/60.a291901e.js"><link rel="prefetch" href="/assets/js/7.2c4bf3fe.js"><link rel="prefetch" href="/assets/js/8.86337e4e.js"><link rel="prefetch" href="/assets/js/9.557cd689.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9825735b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无来</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/docker/" class="sidebar-heading clickable"><span>docker</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docker/docker+jenkins自动化部署.html" class="sidebar-link">docker+jenkins自动化部署</a></li><li><a href="/docker/记录一次docker的学习.html" class="sidebar-link">记录一次docker的学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/js深入浅出/" class="sidebar-heading clickable"><span>js深入浅出</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js深入浅出/es6-let和const.html" class="sidebar-link">es6-let和const</a></li><li><a href="/js深入浅出/es6-箭头函数.html" class="sidebar-link">es6-箭头函数</a></li><li><a href="/js深入浅出/js-new的原理.html" class="sidebar-link">js-new的原理</a></li><li><a href="/js深入浅出/js-原型.html" class="sidebar-link">js-原型</a></li><li><a href="/js深入浅出/map,setMap以及set,wekSet的区别.html" class="sidebar-link">map,setMap以及set,wekSet的区别</a></li><li><a href="/js深入浅出/null 和 undefined 的区别.html" class="sidebar-link">null 和 undefined 的区别</a></li><li><a href="/js深入浅出/sort 的内部实现.html" class="sidebar-link">sort 的内部实现</a></li><li><a href="/js深入浅出/函数执行过程.html" class="sidebar-link">函数执行过程</a></li><li><a href="/js深入浅出/判断类型.html" class="sidebar-link">判断类型</a></li><li><a href="/js深入浅出/数组的冷知识.html" class="sidebar-link">数组的冷知识</a></li><li><a href="/js深入浅出/模块化及区别.html" class="sidebar-link">模块化及区别</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/nginx/" class="sidebar-heading clickable"><span>nginx</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/nginx/nginx 添加环境变量.html" class="sidebar-link">nginx 添加环境变量</a></li><li><a href="/nginx/记录一次nginx反向代理跨域的学习.html" class="sidebar-link">记录一次nginx反向代理跨域的学习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/react/" class="sidebar-heading clickable"><span>react</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/umi中 react嵌套路由父给子路由传参.html" class="sidebar-link">umi中 react嵌套路由父给子路由传参</a></li><li><a href="/react/使用context.html" class="sidebar-link">使用context</a></li><li><a href="/react/解决react路由参数报错.html" class="sidebar-link">解决react路由参数报错</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/vue/" class="sidebar-heading clickable router-link-active open"><span>vue</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/使用动态插槽灵活封装 table 组件.html" class="sidebar-link">使用动态插槽灵活封装 table 组件</a></li><li><a href="/vue/开发心得-自定义指令的妙用.html" class="sidebar-link">开发心得-自定义指令的妙用</a></li><li><a href="/vue/详解 computed 的实现原理.html" class="active sidebar-link">详解 computed 的实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/详解 computed 的实现原理.html#灵魂三问" class="sidebar-link">灵魂三问</a></li><li class="sidebar-sub-header"><a href="/vue/详解 computed 的实现原理.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/vue/详解 computed 的实现原理.html#初始化过程" class="sidebar-link">初始化过程</a></li><li class="sidebar-sub-header"><a href="/vue/详解 computed 的实现原理.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/vue/详解 watch 的实现原理.html" class="sidebar-link">详解 watch 的实现原理</a></li><li><a href="/vue/详解响应式原理.html" class="sidebar-link">详解响应式原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/webpack/" class="sidebar-heading clickable"><span>webpack</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/webpack/webpack 模块化源码分析.html" class="sidebar-link">webpack 模块化源码分析</a></li><li><a href="/webpack/打包情况视图.html" class="sidebar-link">打包情况视图</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/代码片段/" class="sidebar-heading clickable"><span>代码片段</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/代码片段/mac 文件损坏无法打开问题.html" class="sidebar-link">mac 文件损坏无法打开问题</a></li><li><a href="/代码片段/npm, yarn 配置淘宝源.html" class="sidebar-link">npm, yarn 配置淘宝源</a></li><li><a href="/代码片段/vue-高阶组件.html" class="sidebar-link">vue-高阶组件</a></li><li><a href="/代码片段/下载图片或文件.html" class="sidebar-link">下载图片或文件</a></li><li><a href="/代码片段/使用 background 画虚线.html" class="sidebar-link">使用 background 画虚线</a></li><li><a href="/代码片段/使用 require.context 自动注册全局组件.html" class="sidebar-link">context 自动注册全局组件</a></li><li><a href="/代码片段/元素垂直拖动.html" class="sidebar-link">元素垂直拖动</a></li><li><a href="/代码片段/在HTML中根据当前环境插入不同 js 文件.html" class="sidebar-link">在HTML中根据当前环境插入不同 js 文件</a></li><li><a href="/代码片段/自定义 ElementUi-tooltip 的悬浮位置.html" class="sidebar-link">自定义 ElementUi-tooltip 的悬浮位置</a></li><li><a href="/代码片段/记录一次代码提交前的拦截操作.html" class="sidebar-link">记录一次代码提交前的拦截操作</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/基础知识/" class="sidebar-heading clickable"><span>基础知识</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/基础知识/css 加载会阻塞浏览器的执行吗.html" class="sidebar-link">css 加载会阻塞浏览器的执行吗</a></li><li><a href="/基础知识/tcp、udp的区别以及七层模型.html" class="sidebar-link">tcp、udp的区别以及七层模型</a></li><li><a href="/基础知识/vue 和 react 的区别.html" class="sidebar-link">vue 和 react 的区别</a></li><li><a href="/基础知识/性能指标.html" class="sidebar-link">性能指标</a></li><li><a href="/基础知识/浏览器输入url后发生了什么.html" class="sidebar-link">浏览器输入url后发生了什么</a></li><li><a href="/基础知识/理解 node 中的几个路径.html" class="sidebar-link">理解 node 中的几个路径</a></li><li><a href="/基础知识/记录一次SameSite的问题.html" class="sidebar-link">记录一次SameSite的问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/奇奇怪怪的知识点/" class="sidebar-heading clickable"><span>奇奇怪怪的知识点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/奇奇怪怪的知识点/一个会卡死的正则.html" class="sidebar-link">一个会卡死的正则</a></li><li><a href="/奇奇怪怪的知识点/为什么数组中不能展开一个对象.html" class="sidebar-link">为什么数组中不能展开一个对象</a></li><li><a href="/奇奇怪怪的知识点/为什么要使用 require 引入动态图片.html" class="sidebar-link">为什么要使用 require 引入动态图片</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/手写系列/" class="sidebar-heading clickable"><span>手写系列</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/手写系列/实现一个 Vuex 核心功能.html" class="sidebar-link">实现一个 Vuex 核心功能</a></li><li><a href="/手写系列/实现一个 tcp 以及 http 服务.html" class="sidebar-link">实现一个 tcp 以及 http 服务</a></li><li><a href="/手写系列/实现一个千分位分隔符.html" class="sidebar-link">实现一个千分位分隔符</a></li><li><a href="/手写系列/手写call,bind,apply.html" class="sidebar-link">手写call,bind,apply</a></li><li><a href="/手写系列/装饰器.html" class="sidebar-link">装饰器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/算法/" class="sidebar-heading clickable"><span>算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/算法/子集,全排列.html" class="sidebar-link">子集,全排列</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="灵魂三问"><a href="#灵魂三问" class="header-anchor">#</a> 灵魂三问</h2> <p>带着问题看源码：</p> <ol><li><code>computed</code> 是如何实现缓存的？</li> <li><code>computed</code> 是如何收集依赖数据的？</li> <li><code>computed</code>依赖数据更新之后是如何更新视图的？</li></ol> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>相信<code>computed</code>都用过.那么,知其然知其所以然?</p> <h3 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h3> <p><code>computed</code> 是 <code>vue</code> 中的计算属性, 根据依赖关系进行计算并缓存, 只有当依赖被改变的时候才会更新</p> <p><code>computed</code> 一般用于一些复杂的场景, 如受多个数据共同影响的场景</p> <h3 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h3> <p><code>computed</code> 有两种用法</p> <p>一种是常规的函数写法, 默认使用 <code>getter</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>computed: {

  getName() {

    return `${this.firstName}-${this.lastName}`

  }

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其实还可以使用对象的写法, 设置 <code>computed</code> 的 <code>getter</code>, 当值被修改的时候同时修改依赖的属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>computed: {

  getName: {

    get() {

    return `${this.firstName}-${this.lastName}`;

    },

    set(val) {

        const [first, last] = val.split(&quot;-&quot;);
    
        this.firstName = first;
    
        this.lastName = last;

    },

  },

},

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>下面跟着源码直接进入正题</p> <h2 id="初始化过程"><a href="#初始化过程" class="header-anchor">#</a> 初始化过程</h2> <p><code>new Vue(computed)</code> =&gt; <code>initState</code> =&gt; <code>initComputed</code> =&gt; <code>defineComputed[key]</code> =&gt; <code>createComputedGetter</code> =&gt;<code>mountComponent</code></p> <p>大致介绍一下整个流程:</p> <ol><li>首先在 <code>initState</code> 中对传入的 <code>computed</code> 进行初始化</li> <li>初始化的过程中, 为每一个声明的 <code>computed</code>创建 <code>Watcher</code>, 将声明时传入的函数(或者对象声明的 <code>get</code>) 传递给创建的<code>Watcher</code>用于被访问时执行,利用 <code>defineProperty</code> 将声明的 <code>computed</code> 代理到 <code>vm</code> 实例上, 从而跟 <code>data</code> 一样可以通过 <code>this</code> 来访问, <strong>同时用一个函数包装<code>computed</code>的<code>getter</code>(实现缓存的关键)</strong> , 当<code>computed</code>被访问时将执行该函数, 判断是否使用缓存值</li> <li>初始化结束之后会执行 <code>vm.$mount</code>, 对视图进行渲染, 渲染过程中会执行 <code>vm._render</code> 生成 <code>vnode</code> 由于解析到 <code></code> 会触发之前劫持的 <code>getter</code>, 从而执行声明<code>computed</code>时的函数</li> <li>执行声明时传入的函数时, 由于初始化<code>dirty=true</code>, 因此会去获取最新值, 此时会触发其所引用的<code>data</code>中数据的<code>getter</code>, 从而触发响应式系统的依赖收集.<strong>由于此时的 <code>Dep.target</code>为该<code>computerWatcher</code></strong>, 因此会收集该<code>computerWatcher</code>为依赖项</li> <li>当<code>computed</code>依赖的数据被更新时, 会进行消息分发,执行<code>watcher.update()</code>, 若<code>watcher</code>为<code>computedWatcher</code>则将<code>dirty</code>标记为<code>true</code>, 当前订阅的<code>computed</code>被访问时, 触发之前被函数包装的<code>getter</code>, 函数内部识别到<code>dirty===true</code>则获取最新值, 获取完之后接着将<code>dirty</code>置位<code>false</code>. <strong>由于被依赖的数据订阅者中还有用于视图更新的<code>renderWatcher</code>, 因此会接着对视图更新从而渲染最新数据, 这也说明 <code>computedWatcher</code> 要在 <code>renderWatcher</code>之前去更新</strong></li></ol> <p>主要代码如下:</p> <h3 id="initcomputed-创建-computedwatcher"><a href="#initcomputed-创建-computedwatcher" class="header-anchor">#</a> initComputed =&gt; 创建 computedWatcher</h3> <ol><li>在<code>Vue</code>实例上挂载<code>_computedWatchers</code>属性用来存放所有<code>computedWatcher</code></li> <li>为每一个计算属性创建<code>computedWatcher</code></li> <li>使用<code>defineComputed</code>处理定义的每个<code>computed</code></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/core/instance/state.js  
function initComputed(vm: Component, computed: Object) {
  /** 在vm实例上挂载 _computedWatchers 属性存放 computerwatcher */
  const watchers = vm._computedWatchers = Object.create(null)
  /** 判断是否服务端 */
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    /**
     * 1. 判断 computed 属于默认函数写法,还是对象写法  
     * 2. 如果是对象写法则将定义的 get 赋值给 getter
     */
    const getter = typeof userDef === 'function' ? userDef : userDef.get

    if (!isSSR) {
      /** 可以看出本质上 computed 就是一个 watchers 数组, 每一个定义的 computed 都是一个 watcher(computedWatcher) */
      watchers[key] = new Watcher(
        vm,
        /** 将之前申明的 getter 传入 watcher 的 expOrFn, 当 dep.notify 的时候将会执行 */
        getter || noop,
        noop,
        /** computed 实现缓存关键, 值为上面定义的 { lazy: true } */
        computedWatcherOptions
      )
    }

    /** 判断是否有重复的申明 */
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      // ...
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="definecomputed-劫持-getter-实现缓存"><a href="#definecomputed-劫持-getter-实现缓存" class="header-anchor">#</a> defineComputed =&gt; 劫持 getter, 实现缓存</h3> <ol><li>使用<code>Object.defineProperty</code>将计算属性挂载到 <code>vue</code> 实例上, 使其可以通过 <code>this</code> 访问</li> <li>使用 <code>createComputedGetter</code> 包装计算属性的<code>getter</code>函数, 当计算属性被访问的时候执行.通过<code>dirty</code>变量标记是否去获取最新数据</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/core/instance/state.js
export function defineComputed(
  target: any,
  key: string,
  userDef: Object | Function
) {
  /** 判断 computed 属于函数式写法还是对象写法, 目的是拿到其执行函数 */
  if (typeof userDef === &quot;function&quot;) {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    // ...
    }
  /** 挂载到 vue 实例, 通过 this 可以访问 */
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key];
    if (watcher) {
      /** 如果&quot;脏了&quot;, 表示依赖数据被更新, 则需要获取最新数据 */
      if (watcher.dirty) {
        /** 
         * 1. 本质是调用创建 computedWatcher 时, 传入的方法即定义 computed 时写的方法, 从而更新 Watcher 的 value 为最新值 
         * 2. 获取数据之后, 同时将 dirty 置位 false, 进行缓存
         * */
        watcher.evaluate();
      }

      /** 如果有依赖正在收集, 则将该 watcher 下所有发布者添加到正在收集依赖的 watcer 发布者列表里 */
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><p>这里注意一下有这样一步<code>watcher.depend()</code>, 目的是将该 <code>computedWatcher</code>的发布者添加到当前正在收集依赖的<code>Watcher</code>.</p> <p>首先初次渲染页面时, 由<code>renderWatcher</code>进行依赖收集, 当解析模板发现<code></code>时, 触发计算属性的 <code>getter</code>, 执行 <code>watcher.get</code>,此时会将当前<code>watcher</code>压入<code>targetStack</code>依赖收集栈, 同时执行<code>Dep.target = target</code>.即将此时进行依赖收集的<code>renderWatcher</code>修改为当前<code>computedWathcer</code>. 执行计算属性定义函数时,访问到依赖数据,触发响应式系统将<code>Dep.target</code>加入订阅者<code>subs</code>列表中.依赖收集完毕,执行<code>popTarget()</code>弹出收集栈,此时<code>Dep.target</code>修改为之前的<code>renderWatcher</code></p> <p>因此<code>watcher.depend()</code>的最终目的就是将<code>computedWatcher</code>的发布者添加到<code>renderWatcher</code>的发布者列表中, 如果不执行这一步, 计算属性所依赖的属性修改之后,不会触发视图更新, 因为有可能<code>template</code>中只引用了计算属性而没有引用计算属性内部依赖的数据, <code>renderWatcher</code>并没有对依赖数据进行订阅.</p> <h3 id="数据更新"><a href="#数据更新" class="header-anchor">#</a> 数据更新</h3> <p>当计算属性依赖数据被更新时, 会触发响应式数据的<code>setter</code>, 执行<code>dep.notify</code>对所有订阅者进行订阅发布</p> <p>当订阅者为<code>computedWatcher</code>时, 将内部的<code>dirty</code>置为<code>true</code></p> <p>当订阅者为<code>renderWatcher</code>时, 执行<code>vm._update(vm._render)</code>更新视图.扫描数据的同时, 访问到计算属性, 则会执行之前<code>createComputedGetter</code>包装的<code>getter</code>函数, 由于当前<code>computedWatcher</code>内部的<code>dirty</code>已经在上一步被标记为<code>true</code>, 因此会刷新<code>watcher.value</code>, 刷新之后将<code>dirty</code>置为<code>false</code>. 若<code>dirty</code>为<code>false</code>, 则直接获取<code>watcher.value</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// src/core/observer/watcher.js</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 如果this.lazy为true, 说明是 computedWatcher, 通过dirty标记为有更新, 当下一次 computed 被访问的时候, 识别到该字段则会进行数据更新 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>回顾一下之前的问题:</p> <ol><li><code>computed</code> 是如何实现缓存的？</li></ol> <p>答: 通过<code>createComputedGetter</code>包装计算属性的<code>getter</code>,使用<code>dirty</code>标记所依赖的数据有没有更新, 若更新则刷新数据,否则直接返回<code>watcher.value</code></p> <ol start="2"><li><code>computed</code> 是如何收集依赖数据的？</li></ol> <p>答: <code>computed</code>本质上就是一个<code>watcher</code>, 在执行<code>watcher.get</code>时会访问到计算属性所依赖的数据,触发依赖收集系统. 此时的订阅者<code>Dep.target</code>为该<code>coomputedWatcher</code>, 订阅方为所有依赖数据.</p> <ol start="3"><li><code>computed</code>依赖数据更新之后是如何更新视图的？</li></ol> <p>答: 当<code>computed</code>内部依赖数据进行依赖收集的之后, 会将当前<code>renderWatcher</code>也加入到订阅队列中, 即依赖数据更新后先触发<code>computedWatcher.update</code>的, 然后触发<code>renderWatcher.update</code>更新视图</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">1/11/2023, 1:39:01 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue/开发心得-自定义指令的妙用.html" class="prev">
        开发心得-自定义指令的妙用
      </a></span> <span class="next"><a href="/vue/详解 watch 的实现原理.html">
        详解 watch 的实现原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b1ceb87a.js" defer></script><script src="/assets/js/2.dc5a3d57.js" defer></script><script src="/assets/js/29.2ae39443.js" defer></script>
  </body>
</html>
