(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{278:function(v,t,e){"use strict";e.r(t);var a=e(13),_=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"基础建设"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础建设"}},[v._v("#")]),v._v(" 基础建设")]),v._v(" "),t("ul",[t("li",[v._v("vue 的官方团队推出一系列工具, 如 vuex, vue-router并持续维护")]),v._v(" "),t("li",[v._v("react 的官方团队只负责 react 的迭代, 其他工具由社区提供.因此团队也有更多的事件去开发和设计 react 版本")])]),v._v(" "),t("h2",{attrs:{id:"设计思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[v._v("#")]),v._v(" 设计思想")]),v._v(" "),t("ul",[t("li",[v._v("vue 是一个渐进式的框架,用户可以根据需求载入不同的模块,如 vuex, vue-router.核心思想是 "),t("strong",[v._v("组件化 + 数据驱动")]),v._v(". 通过 v-model 实现双向数据绑定.")]),v._v(" "),t("li",[v._v("react 主张函数式编程, 推崇单向数据流, 数据不可变, 而 vue 是可以对数据进行修改的")])]),v._v(" "),t("p",[v._v("vue 和 react 本质上都是一个 ui 库, 通过组合不同的模块从而成为一个 mvvm 框架.")]),v._v(" "),t("h2",{attrs:{id:"语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[v._v("#")]),v._v(" 语法")]),v._v(" "),t("ul",[t("li",[v._v("vue 使用模板语法, 开发中使用 webpack + vue-loader 的方式. 在.vue 文件中保留 html,js,css 分离的写法使开发者更习惯以前的写法")]),v._v(" "),t("li",[v._v("react 使用 jsx 语法 all in js, 学习起来有一定的成本")])]),v._v(" "),t("p",[v._v("相对来说, jsx 语法更灵活,模板语法的限制更多一些.")]),v._v(" "),t("h2",{attrs:{id:"数据绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[v._v("#")]),v._v(" 数据绑定")]),v._v(" "),t("ul",[t("li",[v._v("vue 采用数据劫持和发布-订阅模式, 来实现数据绑定以及数据更新, 通过 getter 和 setter 能精确知道数据变化, 不需要额外的优化")]),v._v(" "),t("li",[v._v("react 是单向数据流, 不允许变更数据属性, 只能通过 setState 来改变数据状态, 同时 setState 是异步的, 会合并之后再执行.  react 通过比对引用来判断数据变化, 如果不做优化,可能导致大量不必要的渲染.")])]),v._v(" "),t("blockquote",[t("p",[v._v("React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。")])]),v._v(" "),t("h2",{attrs:{id:"组件复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件复用"}},[v._v("#")]),v._v(" 组件复用")]),v._v(" "),t("ul",[t("li",[v._v("vue 使用 mixin")]),v._v(" "),t("li",[v._v("react 可以使用 hoc")])]),v._v(" "),t("p",[v._v("mixin 有一定的缺点, 导致难以维护, 如变量的来源不明, 无法重复引用等"),t("br"),v._v("\n其实 vue 也是支持 hoc 的, 但是 vue 中的组件都是被包装过后的函数, 背后经过很多处理, 因此使用起来不是那么方便以及符合预期")]),v._v(" "),t("h2",{attrs:{id:"组件通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[v._v("#")]),v._v(" 组件通信")]),v._v(" "),t("ul",[t("li",[v._v("vue 父子组件通过 props/emit, 非父子组件可以通过 injection/provide. 一般只传递数据,  子组件通过"),t("strong",[v._v("事件")]),v._v("跟父组件通讯")]),v._v(" "),t("li",[v._v("react 通过 props 给子组件传递数据或者回调, 通过 context 跨层级通讯. props 甚至可以传递组件")])]),v._v(" "),t("p",[v._v("本质区别在于 react 可以传递回调,子组件触发回调来跟父组件通讯. vue 只能传递数据, 子组件通过自定义事件跟父组件通讯.")]),v._v(" "),t("h2",{attrs:{id:"事件机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件机制"}},[v._v("#")]),v._v(" 事件机制")]),v._v(" "),t("ul",[t("li",[v._v("vue 使用 native 调用原生事件, 提供事件修饰符")]),v._v(" "),t("li",[v._v("react 实现了自己的一套事件机制, 将所有的事件冒泡到 document 上统一管理. 同时也会对事件进行合成.比如: blur, change, input, keydown, keyup合成为 onchange, 这样带来的好处是:")])]),v._v(" "),t("ol",[t("li",[v._v("一种事件只会注册一次, 提升性能")]),v._v(" "),t("li",[v._v("统一规范, 抹平不同浏览器的差异, 更好的兼容不同的浏览器, 更好的跨平台")]),v._v(" "),t("li",[v._v("方便统一管理")])]),v._v(" "),t("h2",{attrs:{id:"diff-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[v._v("#")]),v._v(" diff 算法")]),v._v(" "),t("ul",[t("li",[v._v("vue 采用用双端比较, 维护 4 个变量, vue 在 diff 的时候就会操作真实 dom")]),v._v(" "),t("li",[v._v("react 从左往右比较")])]),v._v(" "),t("p",[v._v("总体来说, vue 的 diff 算法性能更高一些")])])}),[],!1,null,null,null);t.default=_.exports}}]);