(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{295:function(t,r,a){"use strict";a.r(r);var v=a(13),s=Object(v.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"sort相关原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sort相关原理"}},[t._v("#")]),t._v(" sort相关原理")]),t._v(" "),r("h3",{attrs:{id:"用途及说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用途及说明"}},[t._v("#")]),t._v(" 用途及说明")]),t._v(" "),r("ul",[r("li",[t._v("可以用于数组排序")]),t._v(" "),r("li",[t._v("接受一个 compareFn， 如果没有传递，则将数组转成字符串，并根据"),r("code",[t._v("unicode")]),t._v("进行排序")]),t._v(" "),r("li",[t._v("如果传入的方法返回正数，则降序排序")]),t._v(" "),r("li",[t._v("如果传入的方法反正负数，则升序排序")]),t._v(" "),r("li",[t._v("如果传入的方法返回0，则保持不变")]),t._v(" "),r("li",[t._v("EcmaScript 2019起，规范要求为稳定排序")])]),t._v(" "),r("h3",{attrs:{id:"排序规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#排序规则"}},[t._v("#")]),t._v(" 排序规则")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L709",target:"_blank",rel:"noopener noreferrer"}},[t._v("源码地址"),r("OutboundLink")],1),t._v("，对于需要排序的个数为n，有一下策略：")]),t._v(" "),r("ul",[r("li",[t._v("当 n <= 10，采用插入排序")]),t._v(" "),r("li",[t._v("当 n > 10 采用三路快速排序")]),t._v(" "),r("li",[t._v("10 < n <= 1000 采用中位数作为哨兵元素")]),t._v(" "),r("li",[t._v("n < 1000， 每隔 200-215个元素，选择一个元素，放到一个新的数组中，排序并找到中间的数作为哨兵")])])])}),[],!1,null,null,null);r.default=s.exports}}]);