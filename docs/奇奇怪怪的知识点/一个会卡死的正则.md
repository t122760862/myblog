最近遇到一个正则匹配导致页面卡死的问题

```js
text=' 功能                                                                                 使用软件编码时，性能消耗略大于分层视频编码'  
reg='/ {0,}#{0,} {0,}(\n)?\s{0,}$/gm'
```

经过研究发现原因是所谓的正则“回溯陷阱（Catastrophic Backtracking）"，本文主要记录一下这个问题.  

### 正则表达式引擎  

正则引擎一般分为两种: **DFA 自动机**（Deterministic Final Automata 确定型有穷自动机）和 **NFA 自动机**（Non deterministic Finite Automaton 不确定型有穷自动机）

以一段文本为例:  

```js
text ＝ ‘after tonight’ regex ＝ ‘to(nite|nighta|night)’ 
```

#### DFA自动机  

在DFA匹配时候，采用的是用文本来匹配正则表达式的方式，从`a`开始匹配`t`，直到第一个`t`跟正则的t匹配，但`e`跟`o`匹配失败，继续，直到文本里面的第二个 `t `匹配正则的`t`，接着`o`与`o`匹配，`n`的时候发现正则里面有三个可选匹配，开始并行匹配，直到文本中的g使得第一个可选条件不匹配，继续，直到最后匹配。

* **根据文本匹配正则表达式** 
* 速度快，支持的特性少  
* 不支持捕获组，引用等  

#### NFA自动机  

在NFA匹配时候，是根据正则表达式来匹配文本的，从`t`开始匹配`a`，失败，继续，直到文本里面的第一个`t`，接着比较`o`和`e`，失败，正则回退到` t`，继续，直到文本里面的第二个`t`，然后 `o`和文本里面的`o`也匹配，继续，正则表达式后面有三个可选条件，依次匹配，第一个失败，接着二、三，直到匹配。

* **根据正则表达式匹配文本**  
* 不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，因此速度比较慢  
* 支持更多特性  

对于DFA而言，文本的匹配过程是一致的，都是对文本的字符依次从左到右进行匹配，所以，DFA在匹配过程中是跟正则表达式无关的，而 NFA 对于不同但效果相同的正则表达式，匹配过程是完全不同的。

NFA支持更多的特性，因而绝大多数编程场景下（包括java，js），我们面对的是NFA。

###  NFA自动机的回溯

以一个例子来讲解:  

```js
text = 'abbc'
reg = 'ab{1，3}bc'
```

1. 取出正则中的第一个匹配符`a`去跟字符串的第一个字符开始匹配，命中`a`
2. 取出正则中第二个匹配符`b{1，}`，由于贪婪模式会尽可能多的去匹配`b`，命中 `bb`  
3. 此时匹配符是第三个`b`，同时字符串为第四个字符`c`，没有命中，此时就会发生回溯 
4. 吐出已经读取的第四个字符`c`，取出正则匹配的下一个匹配符`b`，没有命中，继续回溯  
5. 吐出已经读取的第三个字符`b`，拿已经读取的匹配符`b`去匹配，命中 `b` 
6. 取出正则匹配中的最后一个匹配符`c`去跟字符串中的下一个字符`c`匹配，命中  
7. 字符串读取完毕，结束

简单理解贪婪模式会竟可能多的去匹配，若没有命中，会吐出已经读取的字符进行回溯，若还是没有命中会继续回溯  

在看一个例子:  

```js
text = 'abbbc'
reg = 'ab{1，3}bbc'
```

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/ng.png)

其中第7步和第10步是回溯。第7步与第4步一样，此时`b{1,3}`匹配了两个`"b"`，而第10步与第3步一样，此时`b{1,3}`只匹配了一个`"b"`，这也是`b{1,3}`的最终匹配结果。

回头在看卡死的案例:  

```js
/ {0,}#{0,} {0,}(\n)?\s{0,}$/gm
```

卡死的字符串: 

```js
text=' 功能                                                                                 使用软件编码时，性能消耗略大于分层视频编码'  
```

该正则的功能为匹配markdown中的标题#

当匹配到空格之后，后面没有能匹配的内容，因此会进行回溯再次去匹配，由于有几个地方发生了回溯，导致了**回溯陷阱（Catastrophic Backtracking）**  

[regex101](https://regex101.com/)可以查看具体的步骤:  

可以查看发生了十万次匹配，因此可以断定发生了灾难性回溯:  

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/reg101灾难性回溯.png)

###  常见的回溯形式  

简单理解就是因为有很多种可能，所以要一个一个试直到某一步整体匹配成功，或者所有可能都尝试完，发现不匹配.  

>1.  贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。
>
>2.  惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。
>3.  分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。

### 贪婪量词  

贪婪量词比如`b{1,3}`，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试`"bbb"`，然后再看整个正则是否能匹配。不能匹配时，吐出一个`"b"`，即在`"bb"`的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。  

#### 惰性量词  

惰性量词就是在贪婪量词后面加个问号，表示尽可能少的匹配  

虽然惰性量词不贪，但也会有回溯的现象:  

```js
text='12345'
reg='/^\d{1,3}?\d{1,3}$/'
```

匹配过程是:  

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/惰性回溯匹配过程3.png)

为了整体匹配成功，最后`\d{1，3}?`匹配的字符是`"12"`，是两个数字，而不是一个

#### 分支结构  

分支也是惰性的，比如`/can|candy/`，去匹配字符串`"candy"`，得到的结果是`"can"`，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。 

#### 独占模式  

下面的几个特殊字符相信大家都知道它们的用法：

1. ?: 告诉引擎匹配前导字符0次或一次。事实上是表示前导字符是可选的。
2. +: 告诉引擎匹配前导字符1次或多次。
3. *: 告诉引擎匹配前导字符0次或多次。
4. {min, max}: 告诉引擎匹配前导字符min次到max次。min和max都是非负整数。如果有逗号而max被省略了，则表示max没有限制；如果逗号和max都被省略了，则表示重复min次。

默认情况下，这个几个特殊字符都是贪婪的，也就是说，它会根据前导字符去匹配尽可能多的内容。

如果在以上四种表达式后加上一个加号`（+）`，则会开启独占模式。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。

```js
text='abbc'
reg='ab{1，3}+bc'
```

匹配过程:  

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/正则-独占模式匹配过程.png)

可以发现，在第2和第3步，`b{1,3}+`会将文本中的2个字母b都匹配上，结果文本中只剩下一个字母`c`。那么在第4步时，正则中的`b`和文本中的`c`进行匹配，当无法匹配时，并不进行回溯，这时候整个文本就无法和正则表达式发生匹配。如果将正则表达式中的加号`（+）`去掉，那么这个文本整体就是匹配的了。