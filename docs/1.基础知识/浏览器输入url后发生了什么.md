##  1. 真实地址查询 => dns解析

```
dns`: 全称`domain name server
```

`dns`: 专门用来保存域名与ip之间的对应关系

### 域名的层级关系

域名用`.`来分隔, 越靠右层级越高, 最右边的为根域, 其次为顶级域名

* 根域名

* 顶级域名(com, net等)

* 权威域名(baidu.com)

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/顶级域名.jpg)

根域的`dns`服务器信息保存互联网中任何一个`dns`服务器中

因此客户端可以通过任何一台`dns`服务器,找到根域`dns`服务器,再顺藤摸瓜找到下层的某台服务器

> * 全球一共13台`dns`根服务器

### 域名的解析过程

`dns`请求 => host => 根域 => 顶级域名 => 权威域名

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171048194.png)


`dns`域名的解析过程,简单来说**只指路,不带路**

> * 客户端向本地`dns`服务器查询为递归查询
> * 本地`dns`服务器向外网为迭代查询
> * 递归: 客户端只发一次请求,要求对方给出最终结果
> * 迭代: 客户端发送一次请求,对方如果没有返回结果则返回一个能解答这个查询的其他服务器地址,客户端会向返回的地址继续发送请求,知道得到结果
> * 授权回答: 向`dns`服务器发送一个请求,刚好由当前服务器负责,返回的结果就是授权回答

### 协议栈

通过`dns`获取到`ip`地址后,接下来会把http的传输工作交给`协议栈`

协议栈的内部分为几个部分,分别承担不同的工作.上面的部分委托工作给下面的部分,下面的部分负责执行

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171050496.png)

应用程序负责调用socket库来委托协议栈工作.协议栈的上部分有两块,分别是负责收发数据的tcp,udp协议,它们两会接受应用层的委托来执行收发数据的操作

协议栈的下半部分是用ip协议控制网络包的收发工作,在网络数据传输中,数据包会被切割成一块一块的网络包,而将网络包发送给对方的操作由ip负责

此外ip中还包括了`ICMP`协议和`ARP`协议

>`ICMP`: 用来告知网络包传输的过程中产生的错误信息
>`ARP`: 用于根据IP地址定位相应的以太网MAC地址

ip下面的网卡驱动程序用来控制网卡设备硬件,而最下面的网卡则完成实际的收发工作

## 2. 建立http/https连接

### tcp

tcp报文头部格式

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171052232.png)

* 源端口和目标端口是必不可少的,代表收发方

* 序列是为了重新排列,防止包乱序

* 确定序列是为了解决丢包问题,确定包被对方收到,如果没收到进行重新发送

* 一些状态位: `SYN`是发起连接, `ACK`是回复, `FIN`结束连接, `RST`重新连接,tcp是面向连接的,这些标志位会引起双方连接状态的变更

* 窗口大小是用来做**流量控制**, 双方各声明一个窗口(缓存大小),来表示当前能处理的能力,不要饿死也不要饱死

* tcp会做**拥塞控制**, 限制自己的发送的速度

### 三次握手

HTTP在传输数据前,首先要进行tcp的链接,一般称为3次握手

所谓的连接,其实是双方维持一个状态机,在连接的过程中,状态变化的时序图如下:

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171053712.png)

1. 首先客户端和服务端都处于`close`状态, 服务端对端口进行监听,变成`listen`状态

2. 客服端发起连接请求`SYN`,之后处于`syn-sent`等待连接状态

3. 服务端`ACK`客户端的`SYN`,并向客户端发送`SYN`,之后处于`syn-rcvd`等待对连接请求的确认状态

4. 客户端`ACK`服务端的`ACK`,完成一发一收,之后处于`established`连接状态

5. 服务端收到`ACK`的`ACK`后,完成一收一发,处于`established`连接状态

三次握手的目的是为了保证双方都有收发能力

## 3. 进行数据传输

### tcp 分割数据

如果http的信息过长,超过了`MSS`的长度,tcp会对数据进行切割,而不是一次性发送  

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171053909.png)

`MTU`: 全称`Maximum Transmission Unit`,一个网络包的最大长度,以太网中一般为1500字节,包括ip头部,tcp头部以及数据

`MSS`: 除ip头部以及tcp头部之后,一个网络包能包含数据的最大长度

数据会被以`MSS`长度的单位进行分割,然后添加tcp头部,交给ip模块进行传输,形成单独的网络包

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171053747.png)

### tcp 报文生成

tcp的数据部分用来存放http头部+数据,组装好tcp报文后交给网络层进行处理.至此,网络包的结构如下:

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171054888.png)

### ip => 远程定位

tcp模块在执行收发,连接,断开等阶段的操作时,都需要委托ip模块将数据包封装成网络包发送给通信对象

IP包头格式:

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171057743.png)

ip协议里需要有源地址ip和目标地址ip

> 源地址ip: 发送端客户端地址ip

> 目标地址ip: 通过dns解析获取的接收方地址ip

因为http是经过tcp传输的,因此在ip包头的协议号要填写**06**(16进制),表示协议为tcp

如果有多个网卡,就有多个ip,此时需要路由表来判断源地址ip

至此ip报文生成:

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171057743.png)

### 两点传输 => MAC地址

MAC头部是以太网使用的头部,它包含了发送方和接收方的MAC信息:

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171100766.png)

一般的TCP/IP通讯里,MAC包头的协议类型只使用:

> 0800: IP协议
> 0806: ARP协议   

MAC的发送方和接收方如何确定?  
**发送方**:  MAC地址在网卡生产时已经写入了ROM,只要在数据发送时,拿到该数据并插入到MAC头部就行   
**接收方**: 通过ARP协议找到对方的MAC地址  

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171101023.png)  

ARP协议会以**广播**的形式在以太网中寻找MAC地址  
并不是每次都会广播,可以对数据进行缓存  
*  先查询`ARP`缓存,如果有缓存直接读取  
*  如果没有缓存则广播  

至此MAC报文生成:  

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171102321.png)  

###  网卡  
IP生成的网络包只是存在于内存中的电信号,不能直接用来发送.需要使用网卡将数字信号转换为电信号.这才是真正的数据发送过程.  

网卡由网卡驱动控制.网卡驱动从ip模块中获取到包之后,会在**开始位置加上起始帧分解符,在末尾插入用来检测错误的帧检验序列** 

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171102623.png)  

> 起始帧分解符是一个用来表示包起始位置的标记  
> 末尾的FCS(帧校验序列)用来检查包传输过程中是否有损坏  

最后网卡会将包转换为电信号,通过网线发出去  

###  交换机  
交换机是用来将包原样转发到目的地,工作在MAC层,也称为二层网络设备  

交换机收到电信号后,会转换为数字信号,通过数据包的FCS(帧校验序列)检验错误,如果没有问题会保存在缓存区.  

计算机网卡具有MAC地址,并判断收到的包接受方MAC地址是不是自己,如果不是则丢弃;相对的,**交换机没有MAC地址,不核对接收方的MAC地址,会接受所有的包并放到缓冲区内**.  

将包放到缓冲区后,会在MAC地址表中查询接收方的MAC地址记录  

交换机的MAC地址表包含两个内容:  
* 设备的MAC地址  
* MAC对应的设备对应的链接端口

![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171102782.png)

总结: 交换机**通过MAC地址表查询MAC地址,并发送到对应的端口**  

如果MAC地址表找不到对应的MAC信息,可能是第一次接收到,或者被删除记录.这是交换机会将包转发给除源端口外的所有端口.只要有端口做出响应,将记录改MAC地址信息  

此外如果MAC地址是一个**广播**地址,交换机会发送给除源端口外的所有端口  
> MAC地址中的 `FF:FF:FF:FF`  
> IP地址中的 `255.255.255.255`  

### 路由器  
网络包经过交换机之后会到达**路由器**,并在此转发给下一个路由器或目标设备  

转发过程跟交换机类似,都是通过查表确定下一个转发目标  

区别在于:  
*  路由器是基于IP设计的,俗称**三层网络设备**,因此每个端口都具有MAC地址和IP地址,从意义上来说,跟网卡一样  
*  交换机是基于以太网设计的, 俗称**二层网络设备**,交换机的端口不具有MAC地址和IP地址  

当转发包时,首先路由器会接收发送给自己的包,然后通过**路由表**查询转发目标,再由相应的端口作为发送方发送将以太网包发送出去  

接收过程:  
1. 接收到包时,路由器中的模块会将电信号转换为数字信号,通过包末尾的`FCS`进行错误校验  
2. 检查`MAC`头部的`MAC`地址是不是自己,是的话就放缓冲区,不是就丢弃  

接收完成之后,会`丢弃`包的MAC头部.**MAC头部的作用就是将包送达路由器**,其中接收方的MAC地址就是路由器端口的MAC地址.  

接下来路由器会通过IP头部的IP地址对包进行转发:  
1. 查询路由表
2. 根据**路由表的网关列**判断对方的地址  
* 如果网关是一个IP地址,则这个地址是下一次要转发的目标,**还未抵达终端**,需要路由器继续转发  
* 如果网关为空,则IP头部的接收方IP地址就是要转发的目的地之,说明**抵达终点**  
3. 知道对方的IP地址后,会通过`ARP`协议进行广播查询MAC地址,并将查询的过程作为接收方的MAC地址.路由器ARP也具有缓存,查询不到才会发送ARP查询请求  

发送出去的网络包会通过**交换机**到达下一个路由器,接下来路由器会将包发送给另一个路由器,经过层层转发,到达最终目的地.  

###  互相拆包 => 服务端与客户端  
![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171103279.png)  

1. 服务器首先扒开MAC头部,查看是否跟自己的MAC地址符合,符合会接收  
2. 扒开IP头部,发现IP地址符合,根据协议知道上层是TCP协议  
3. 扒开TCP头部,里面有序列号,确定返回一个ACK,不是则就丢弃.TCP还有端口号,HTTP服务监听该端口号,发送给对应的HTTP进程  
4. HTTP进程响应请求,将数据封装在HTTP响应报文里
5. HTTP响应报文也需要穿上TCP头部,IP头部,MAC头部,不过这一次发送方和接收方交换  
6. 客户端收到响应,进行拆包

## 4. 断开连接  
### 四次挥手  
![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171103500.png)

## 5. 浏览器渲染页面  
![](https://cdn.jsdelivr.net/gh/t122760862/blogimg@main/202210171103578.png)  

1. 将载入的html文件解析成DOM树(DOM tree),并将各个标记标识解析成DOM树的各个节点,同时将CSS文件解析成CSS规则(CSS Rules)  
2. 将解析的DOM tree和CSS Rules进行关联,生成渲染书(Render Tree)
3. 进入渲染阶段,为DOM树的每个节点分配屏幕上出现的真实坐标(这一阶段还是在渲染树)
4. 进入绘制阶段,渲染引擎工作结束,对渲染树的每个节点进行绘制,呈现页面  

> CSS被视为`渲染阻塞资源(包括js)`,CSS 规则树渲染完毕,才会进行下一阶段  
> js文件被认为是`解释器阻塞资源`,HTML解析会被js阻塞,因为ji文件可以修改和读取DOM属性以及CSSOM属性  

GUI渲染引擎跟js引擎线程是互斥的:  
> 当浏览器遇到一个js标记是,DOM Tree的构建将暂停,直至脚本执行完成  
> CSSOM构建时,js文件将暂停执行,直至CSSOM就绪  

原则:  
1. CSS优先: 引入顺序上 CSS文件 > js文件
2. js文件尽量放底部    

tips:
> link标签会被视为阻塞渲染的资源,浏览器会优先处理这些资源,直至CSSOM构建完成

### CSS的加载阻塞情况  
1. css的加载不会阻塞DOM树的构建  
2. CSS的加载会阻塞DOM树的渲染  
3. css的加载会阻塞js语句的执行  

### js => defer/async  
defer: 表示延迟执行js文件,即js加载时HTML不停止解析,这两个过程并行.当两者都完成时,执行所有defer加载的js代码. 
> defer不会改变js代码的执行顺序  
> 不阻塞HTML的解析,执行阶段放在HTML解析完成之后  

async: 表示异步加载js文件, 加载完成之后立即执行,无论此刻HTML处于解析阶段还是解析完成之后  
> async 执行顺序不固定  
> async 阻塞load事件,一定会在load事件之前执行



